local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local plr = Players.LocalPlayer
local cam = Workspace.CurrentCamera

local visited = {}
local started = false

local function getHumanoidRootPart()
	local char = plr.Character or plr.CharacterAdded:Wait()
	return char:WaitForChild("HumanoidRootPart")
end

local function collectBases()
	local bases = {}
	for _, map in pairs(Workspace.Maps:GetChildren()) do
		if map:FindFirstChild("Gameplay") and map.Gameplay:FindFirstChild("Buttons") then
			for _, model in pairs(map.Gameplay.Buttons:GetChildren()) do
				if model:IsA("Model") and model:FindFirstChild("Base") then
					table.insert(bases, model.Base)
				end
			end
		end
	end
	return bases
end

local function teleportToBase(base)
	local hrp = getHumanoidRootPart()
	local basePos = base.Position
	local direction = base.CFrame.LookVector.Unit
	local teleportPos = basePos + direction * 5 + Vector3.new(0, 3, 0)

	hrp.CFrame = CFrame.new(teleportPos)
	task.wait(0.2)  -- wait for physics to update

	-- Camera setup
	local camPos = hrp.Position + Vector3.new(0, 2, 0)
	local lookDirection = (basePos - camPos).Unit
	local right = Vector3.new(0, 1, 0):Cross(lookDirection).Unit
	local up = lookDirection:Cross(right).Unit

	cam.CameraType = Enum.CameraType.Scriptable
	cam.CFrame = CFrame.fromMatrix(camPos, right, up)
end

local function startSequence()
	local bases = collectBases()
	local visited = {}

	for _, base in ipairs(bases) do
		if not visited[base] then
			visited[base] = true
			teleportToBase(base)
			task.wait(1)
		end
	end

	cam.CameraType = Enum.CameraType.Custom -- reset camera control
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.K and not started then
		started = true
		startSequence()
	end
end)
